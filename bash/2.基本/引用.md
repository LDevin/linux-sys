[TOC]



# 热身

## 为什么使用`shell`

  作为一个从事嵌入式行业的开发人员，每天要打交道的就是和`Linux`的`shell`串口，更准却的来说是`bash shell`，很多人刚从`windows`的界面操作转到`Linux`上来时，对看到`Linux`这个弹出来的控制窗口，多少有点不知所措，甚至有点茫然。

书读了一本又一本，博客写了一篇又一篇，可能是因为从事行业的性质决定的，也可能是因为自己总是爱学习点新鲜的工具导致。虽学了各种语言各种库，但是回过头来看这些学过的知识，仅存在自己的脑海中，平时工作生活中能用到的可能百分之20都不到，这也许就是进店的二八理论吧-你学的知识只有百分之二十是能够用到的，反过来当你学会使用一个工具的百分之二十的功能时，你就能够熟练的使用它，让我们带着这种二八理论来一起学会使用`bash shell`的百分之二十的使用方式吧。

`shell`是什么，你可以说`shell`是一个程序、一个命令解析器、一个介于用户和操作系统之间的绝缘层，一种计算机语言、一种脚本语言... ，这些答案都是对的，至于那些权威的官方解析，大家可以自行进行百度，会这查看`wiki`解释，在`linux`中`shell`能够将系统调用、公共程序、工具、编译的二进制文件粘合在一起来建立应用，如果你是在`linux`上从事开发工作，建议你学好`shell`，熟练掌握`shell`之后，你根本不需要那些华而不实成熟紧凑的程序。

## 带着一个`Sha-Bang`出发(`Sha-Bang`是指`#!`)

`shell`脚本就是一堆系统命令列在一个文件中，因此它可以帮助你少敲一些命令。

写一个脚本

```bash
ls
pwd
ifconfig
```

脚本写好之后，将其保存为`example.sh`^1^，执行可以直接调用`bash`来执行这个脚本，或者加上可执行权限之后在直接执行对应的文件，

1. 使用`bash`执行

```bash
bash example1.sh
```

2. 加上可执行权限执行

```bash
chmod 666 example1.sh
./example1.sh
```

当然你可以更加细化的添加权限的管理

比如:

```bash
chmod 555 scriptname (允许任何人都具有可读和执行权限) 
chmod +rx scriptname (允许任何人都具有可读和执行权限)
```

或者

```bash
chmod u+rx scriptname
```



[1]:文件路径`1.热身/src`

-----

:one:

实现一个清除文件内筒的脚本:

```bash
echo "cat example"
cat /dev/null > messages
echo "file is cleanup"
exit
```

该脚本实现了，将当前文件夹下的`messages`文件中的内筒清空，

`echo`是打印命令

`/dev/null`/ 在类`UNIX`系统中，`/dev/null`，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个`EOF`。
在程序员行话，尤其是`UNIX`行话中，`/dev/null `被称为位桶(`bit bucket`)或者黑洞(`black hole`)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。当你读它的时候，它会提供无限的空字符(`NULL, ASCII NUL`, `0x00`)。

改进一下

执行脚本：

```bash
bash cat_example2.sh filename
```

```bash
#! /bin/bash
echo "cat cleanup example2"

# 确保输入文件名，否则退出
if test $# != 1 ; then
    echo "请输入要清除文件内容的文件名"
    # 脚本退出返回的值，可通过 echo $? 查看
    exit 1
fi

FILE_NAME=$1
cat /dev/null > ${FILE_NAME}

echo "file is cleanup"
exit #这是一个退出命令
```

对你没有看错，你在`shell`中能向其他语言脚本一样使用判断条件，改进之后的脚本用户可以指定要清除内容的文件名，并且当检测不到文件名输入的时候脚本会报错退出并返回`1`

```bash
$# 是传给脚本的参数个数
$0 是脚本本身的名字
$1 是传递给该shell脚本的第一个参数
$2 是传递给该shell脚本的第二个参数
$@ 是传给脚本的所有参数的列表
$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个
$$ 是脚本运行的当前进程ID号
$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误
```

要注意,在每个脚本的开头都使用 `sha-bang `(` #!`), 这意味着告诉你的系统这个文件的执行需要指定一个解释器. #! 实际上是一个2字节的魔法数字, 这是指定一个文件类型的特殊标记, 换句话说,在这种情况下, 指的就是一个可执行的脚本(键入 man magic 来获得关于这个迷人话题的更多详细信息)。
在`sha-bang`之后接着是一个路径名. 这个路径名就是解释脚本中命令的解释程序所在的路径, 可能是一个`shell`, 也可能是一个程序语言, 也可能是一个工具包中的命令程序. 这个解释程序从头开始解释并且执行脚本中的命令(从 `sha-bang`行下边的一行开始)。

当然#!也可以被忽略, 不过这样你的脚本文件就只能是一些命令的集合, 不能够使用`shell`内建的指令了。再次提醒你 `#!/bin/sh `将会调用默认的`shell`解释器, 在Linux机器上默认是 `/bin/bash` .

```bash
1 #!/bin/sh
2 #!/bin/bash
3 #!/usr/bin/perl
4 #!/usr/bin/tcl
5 #!/bin/sed -f
6 #!/usr/awk -f
```







