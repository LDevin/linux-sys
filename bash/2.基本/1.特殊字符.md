[TOC]



## 特殊字符

在`<<shell热身>>`大家对`shell`算是有个初步的了解，初步连接之后肯定想知道，这个工具怎样用，带着这些疑问，我们首先向探索其他语言一样，探索一下`shell`中的特殊字符以及其含义。

### `#`

1. 注释。但是行首(`#!`)开头是个例外，除了行首其他行的`#`均代表注释

```bash
# 这是一行注释。
```

当然注释也可以在一个命令行的后面，但是命令行不能在注释的后面

```bash
echo "后面会有一行注释"  # 注释的#与前面的语句要有空白 
```

注释可以不用定格写

```bash
            # 这样也能写注释
```

当然转义之后的`#`是不能作为注释的，标准的引用和转义字符`("'\'")` 等可以用来转义`#`

### `;`

命令分隔符，可以在同一行上写两个或多个命令。

```bash
echo "这是一个命令"; ls ; pwd
```

###  `;;`

终止`case`选项

```bash
#! /bin/bash
# $1 是输入给脚本的参数，如 bash case.sh 1 或 ./case.sh 1
case $1 in
1) echo "\$1 = 1" ;;
2) echo "\$1 = 2" ;;
esac
```



###  `.`

等价与`source`命令，是`bash`的一个内建命令，挡在脚本中使用这个命令加载一个脚本文件

点作为文件名的一部分，如果放在文件开头的话，那么将隐藏这个文件，并且使用`ls`命令也无法查看这个文件，需要通过`ls -a`命令才能显示隐藏文件

如果作为目录的话，一个单独的点，表示当前目录，两个点表示上一层目录

用于匹配的时候，正则中`.`可以匹配任何的单个字符

### `""`

双引号会阻止 "string"， `string`中的大部分特殊字符

### `''`

单引号，会阻止`'string'`中的所有特殊字符

### `，`

逗号操作符. 逗号操作符链接了一系列的算术操作. 虽然里边所有的内容都被运行了,但只有最后一项被返回.

```bash
let "t2 = ((a = 9, 15 /3))"  # Set "a=9" and "t2 = 15 / 3"
```

### `\`

转义字符，输出特殊字符时需要使用转义字符才能将特殊字符原样输出

```bash
echo "\" 打印双引号  "
```

### `/`

文件路径分隔符

###  ` ` `

命令替换

### `:`

- 空命令，相当于执行`NOP`,总是返回成功，与bash的内建命令`true`相同，`:`是一个`bash`的内建命令，退出码(exit status)是`true`（0）

```bash
:
echo $?  # 0
```

```bash
while :
do
    operation-1
    operation-2
    ...
    operation-n
done

# 与下边相同:
#   while true
#   do
#     ...
#   done
```

- 占位符

`if/then`中的占位符：

```bash
if condition
then : 什么都不做，引出分支
else 
	tack-some-action
fi
```

在一个二元命令中提供一个占位符

```bash
: ${username=`whoami`}
# ${username=`whoami`} 如果没有开头的 ":"的话，将会给出一个错误，除非"username"是一个命令或者内建命令
```

- 使用参数替换来评估字符串变量
  

  如果一个或者多个必要的环境变量没有被设置的话，就打印错误信息

`char_cap.sh`

```bash
#!/bin/bash

# 检查一些系统环境变量.
# 这是一种可以做一些预防性保护措施的好习惯.
# 比如, 如果$USER(用户在控制台上中的名字)没有被设置的话,
#+ 那么系统就会不认你.
: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo "Name of the machine is $HOSTNAME."
  echo "You are $USER."
  echo "Your home directory is $HOME."
  echo "Your mail INBOX is located in $MAIL."
  echo
  echo "If you are reading this message,"
  echo "critical environmental variables have been set."
  echo
```

- 创建空文件

与重定向符`>`结合使用使用时，将会把一个文件清空，但是并不会修改这个文件的权限，如果之前这个文件并不存在，那么就创建这个文件

```bash
: > test.txt # 文件test.txt如果存在现在就被清空了，如果不存在就会被创建
# 这个命令与cat /dev/null > test.txt效果是一样的，但是实现过程不一样，应为后者需要创建一个进程来实现文件的创建或者清空，但是前者是bash的内建命令
```

与重定向操作符`>>`结合使用，将不会对预先存在的目标文件产生任何影响，如果这个文件之前并不存在，那么就创建它

当然`:`还可以用来做变量中的分隔符

==注意==：以上操作的文件只使用于正规的文件，而不适用于管道，符号连接，和某些特殊文件。

### `！`

叹号，可以翻转测试操作符表达的意义，比如修改等号`=`为不等`!=`，还可以反转命令的退出码的结果，`!`操作符是`Bash`的关键字。

###　`*`

通配符，* 可以用来做文件名的匹配，这个东西也有个专有名词"通配符"，含义就是可以用来匹配目录下的任何文件名。

也可以用与正则表达式中，用来表示匹配任一个数(包含0)的字符。

```bash
bash:/work/linux-sys/bash/2.基本/src$ echo *
case.sh char_cap.sh escape_character.sh multi_commond.sh testfile
```

当`* `作为算术运算符时，指进行乘法的运算，如果要进行求幂的运算，需要使用`**`

### `?`

测试操作符。在一个特定的表达式中，`?`用来测试一个条件的结果

在一个双括号结构中，`?`就是C语言的三元操作符。

在参数替换表达式中，`?`用来测试一个变量是否被`set`了

通配符，`?`在通配中，用来做匹配的单个字符的"通配符"，在正则表达式中也是用来表示一个字符

### `$`

- 变量替换－－引用变量的内容，在一个变量前面加上`$ `用来引用这个变量的值

- 行结束符

在正则表达式中`$`表示行结束符

- `${}`

参数替换

- `$*, $@`

位置参数

`$?`

退出状态吗变量，`$?`变量保存了一个命令，一个函数，或者是脚本本身的退出状态码

`$$`

进程`ID`变量，这个`$$`变量保存了它在脚本的进程`ID`

### `()`

命令组，在括号中的命令列表，将会作为一个子`shell`来运行。在括号中的变量，由于是在子`shell`中，所以对于脚本上下的部分是不可用的

### `{xxx,yyy,zzz,...}`
大括号扩展.

```bash
cat {file1,file2,file3} > combined_file
# 把file1, file2, file3连接在一起, 并且重定向到combined_file中.
cp file22.{txt,backup}
# 拷贝"file22.txt"到"file22.backup"中
```

==注意==:在大括号中, 不允许有空白, 除非这个空白被引用或转义

### {}

代码块，即称为内部组，这个结构实时上创建了一个匿名函数，但是与标准函数不同的是在这个匿名函数中创建的变量对于其他部分的代码来说是可见的。

```bash
#!/bin/bash
# rpm-check.sh

# 这个脚本的目的是为了描述, 列表, 和确定是否可以安装一个rpm包.
# 在一个文件中保存输出.
#
# 这个脚本使用一个代码块来展示.

SUCCESS=0
E_NOARGS=65

if [ -z "$1" ]
then
echo "Usage: `basename $0` rpm-file"
exit $E_NOARGS
fi
 
{
	echo
	echo "Archive Description:"

# 查询说明.
	echo
	echo "Archive Listing:"

# 查询列表.
	echo

	if [ "$?" -eq $SUCCESS ]
	then
	
		echo "$1 can be installed."
	else
		echo "$1 cannot be installed."
	fi
	echo
	} > "$1.test"
# 把代码块中的所有输出都重定向到文件中.

echo "Results of rpm test in file $1.test"

# 查看rpm的man页来查看rpm的选项.
 
exit 0
```

### `{} \;`

路径名，配合`find`等使用，

```bash
# 在当前目录下，查找后缀为sh的文件，并执行chmod u+x对找到的文件加上可执行权限
find . -name '*.sh' -exec chmod u+x {} \;
```

### `[]`

- 条件测试，条件测试表达式放在`[]`中，该命令是`shell`内建命令的一部分，并不是`/usr/bin/test`中的外部命令的一个链接。
- 数组元素

```bash
array[1]='a';
```

- 字符范围

用于正则表达式的一部分，方括号描述一个匹配的字符范围

### `[[]]`

测试，测试表达式放在`[[]]`(`shell关键字`)

### `(())`

整数扩展

扩展计算在`(())`中的整数表达式

### `> &> >> < <>`

重定向

### `<<、<<<`

用在`here document`中的重定向

### `<、>`

大小比较

### `\<、\>`

正则表达式中单词的边界

### `|`

管道

### `>|`

强制重定向，将覆盖一个现存的文件

### `||`

条件表达式中，或逻辑操作

### `&`

后台运行

### `&&`

与－逻辑操作

### `-`

- 选项前缀，所有的命令内，如果向使用选项参数的话，其那边都要加上"-"

- 用于重定向 `stdin` 或 `stdout` [破折号, 即-].

```bash
# １'-'后边的'f'(file)选项, 指明作为stdout的目标文件
# 2'f'后边跟'-',从stdin读取数据.
tar cf - . | (cd ../dest/directory; tar xpvf -)

```

- 先前的工作目录，使用`cd -`将回到先前的工作目录

- 减号操作符

### `=`

等号，赋值操作，也可以用来做字符串比较等价于`==`

```bash
if [ "$a" = "$b" ]
```

### `+`

加号。加法算术操作，也可以作为一种正则表达式的操作

作为选项时，某些命令使用`+`来表示打开特定的选型，使用`-`来标示禁用这些特定的选项

### `%`

取模，一次除法的余数，算术操作，也可以是一种模式匹配的操作

### `~`

代表`home`目录

### `~+`

当前工作目录，相当于`$PWD`的内建命令

### `~-`

先前的工作目录，相当于`$OLDPWD`的内部变量

### `^`

行首，在正则表达式中`^`代表定位到文本行的行首



[]()





















































