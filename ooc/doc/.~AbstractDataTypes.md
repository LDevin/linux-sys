# `AbstractDataTypes`



## C语言的灵活

C语言很灵活，不但有基础数据类型，char、int、double等，还允许程序员自定义类型，如：

定义一个链表使用的数据类型，其中有Node节点和自己需要使用的其他数据信息。

```c
typedef struct node {
    struct node * next;
    ... information ...
} node;
```



## 一个小例子-set

`set`会有这些操作：

```c
#ifndef	SET_H
#define	SET_H

extern const void * Set;

void * add (void * set, const void * element);
void * find (const void * set, const void * element);
void * drop (void * set, const void * element);
int contains (const void * set, const void * element);
unsigned count (const void * set);

#endif
```

这些方法中`set`就是一个抽象数据类型，而这些方法描述的是我们能对`set`进行的操作。

`add`向`set`中添加一个`element`

`find`查找一个`element`是否在`set`中

`drop`将一个`element`从`set`中剔除

`contains`将`find`的结果转变为真假值

`set`类型定义成`void`类型是为了能够像`set`传递任何类型的数据+

### 内存管理函数方法

在`new.h`中定义了内存管理的方法

`new`和`delete`是用来代替`ANSI-C`中的`calloc`还有`free`方法的

```c
#ifndef	NEW_H
#define	NEW_H

void * new (const void * type, ...);
void delete (void * item);

#endif
```



### 对象

想让`set`更有意思，我们需要另外一个抽象数据类型`Object`

```c
#ifndef	OBJECT_H
#define	OBJECT_H

extern const void * Object;		/* new(Object); */

int differ (const void * a, const void * b);

#endif
```



`differ`用于对比`Objects`是否相等。



### 一个小应用

这也是这里说明的重点，不同的实现方式但是表现形式是一样的，这就达到了数据抽象的效果，同一个应用程序框架，底层更换之后，程序还是能正常运行。

```c
#include <stdio.h>

#include "new.h"
#include "Object.h"
#include "Set.h"

int main ()
{	
    /* 新建一个Set对象 */
    void * s = new(Set);  //*s = 10
    /* 将一个新建的Object添加到s中 */
	void * a = add(s, new(Object)); //*a = 1
    /* 将一个新建的Object添加到s中 */  
	void * b = add(s, new(Object));   // *b = 1
    /* 新建一个  Object 对象*/
	void * c = new(Object); //  *c = 10

     /* s中是佛包含 a 是否包含b */
	if (contains(s, a) && contains(s, b))
		puts("ok");
	/* s中是否含有c */
	if (contains(s, c))
		puts("contains?");
	/*  a, add(s, a)) 相同*/
	if (differ(a, add(s, a)))
		puts("differ?");
	
	if (contains(s, drop(s, a)))
		puts("drop?");

	delete(drop(s, b));
	delete(drop(s, c));

	return 0;
}

```



```c
#include <assert.h>
#include <stdio.h>

#include "new.h"
#include "Set.h"
#include "Object.h"

const void * Set;
const void * Object;

#if ! defined MANY || MANY < 1
#define	MANY	10
#endif

/* 定义一个数组用于模拟堆 */
static int heap [MANY];

/* 创建一个对象，这里使用在堆里赋值MANY表示 */
void * new (const void * type, ...)
{	int * p;							/* & heap[1..] */

	for (p = heap + 1; p < heap + MANY; ++ p)
		if (! * p)
			break;
	assert(p < heap + MANY);
	* p = MANY;
	return p;
}
/* 删除一个对象，将对应数组中的值进行清空表示 */
void delete (void * _item)
{	int * item = _item;

	if (item)
	{	assert(item > heap && item < heap + MANY);
		* item = 0;
	}
}
/* 向_set中添加一个  _element元素 */
void * add (void * _set, const void * _element)
{	int * set = _set;
	const int * element = _element;

	assert(set > heap && set < heap + MANY);
	assert(* set == MANY);
	assert(element > heap && element < heap + MANY);

	if (* element == MANY)
		* (int *) element = set - heap;
	else
		assert(* element == set - heap);

	return (void *) element;
}
/* 查找_set中是否有_element */
void * find (const void * _set, const void * _element)
{	const int * set = _set;
	const int * element = _element;

	assert(set > heap && set < heap + MANY);
	assert(* set == MANY);
	assert(element > heap && element < heap + MANY);
	assert(* element);

	return * element == set - heap ? (void *) element : 0;
}
/* 将_set是否包含_element转换为是否为真 */
int contains (const void * _set, const void * _element)
{
	return find(_set, _element) != 0;
}
/* 从_set中删除 _element */
void * drop (void * _set, const void * _element)
{	int * element = find(_set, _element);

	if (element)
		* element = MANY;
	return element;
}
/* 对比a与b是否相同 */
int differ (const void * a, const void * b)
{
	return a != b;
}

```



到这里整个`set`的例子就结束了，接下来看下`Bags`的例子，通过这两个例子的对比你就能明白如何通过设计良好的数据类型也就是对数据进行抽象，来达到代码复用，同一个应用程序，调用同样的接口来达到不同的目的。

----

## 另外一个例子—Bag

`Bag`例子使用的主函数和`set`一样但是实现不一样，达到的效果就是对数据进行抽象之后，使用同一个框架运行不同的底层程序。

















