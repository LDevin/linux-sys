1. ulimit -c

查看系统的核心转存储是否被限制为0 ，若是被限制为0使用

2. ulimit -c unlimited

将核心转存储设置为无限制

3. 编译程序加上-g 选项

4. 调试
要想使用GDB调试内核转存储文件，应当以以下方式启动GDB

gdb -c core文件 ./a.out

在使用大型文件系统时，会希望将内核转存储放在固定的位置。默认情况下会在当前目录下生成，但是可能很难弄清文件在哪在哪生成。这种情况下可以配置/etc/systl.conf文件，来决定文件的生成目录和文件的命名；

例如在/etc/systl.conf 文件中添加如下内容：
kernel.core_pattern = /var/core/%t-%e-%p-%c.core
kernel.core_uses_pid = 0
然后执行
# sysctl -p 
上述生成核心转存储文件的命名：
时刻-进程名-PID-内核转存储最大大小.core
kernel.core_pattern中可以设置的格式符：
```
格式符                    说明
%%		          %字符自身
%p                        被转存储进程的进程ID(PID)
%u                        被转存储进程的真实用户ID(real UID)
%g                        被转存储进程的真实组ID(real GID)
%s                        引发转存储的信号编号
%t                        转存储时刻(从1970年1月1日 0:00 开始的秒数)
%h                        主机名(同uname(2)返回的nodename)
%e                        可执行文件名
%c                        转存储文件的大小上限(内核版本2.6.24以后可以使用)

```
kernel.core_uses_pid = 0 设置为0是因为我们改变了文件名中的PID的位置，如果设置该值为1，文件名末尾就会添加.PID



# ==========================================================================
# segment.c文件示例

同步博客地址
https://blog.csdn.net/andrewgithub/article/details/86634840

```
andrew@andrew-Thurley:/work/linux-sys/DEBUG/segmentation$ gdb -c core ./segment
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./segment...done.
[New LWP 7103]
Core was generated by `./segment'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004004ed in main (argc=1, argv=0x7ffcab228948) at segment.c:16
16	    (*a) = 1;
(gdb) bt full
#0  0x00000000004004ed in main (argc=1, argv=0x7ffcab228948) at segment.c:16
        a = 0x0
(gdb) bt
#0  0x00000000004004ed in main (argc=1, argv=0x7ffcab228948) at segment.c:16
(gdb) frame 0
#0  0x00000000004004ed in main (argc=1, argv=0x7ffcab228948) at segment.c:16
16	    (*a) = 1;

(gdb) disassemble 0x00000000004004ed
Dump of assembler code for function main:
   0x00000000004004d6 <+0>:	push   %rbp
   0x00000000004004d7 <+1>:	mov    %rsp,%rbp
   0x00000000004004da <+4>:	mov    %edi,-0x14(%rbp)
   0x00000000004004dd <+7>:	mov    %rsi,-0x20(%rbp)
   0x00000000004004e1 <+11>:	movq   $0x0,-0x8(%rbp)
   0x00000000004004e9 <+19>:	mov    -0x8(%rbp),%rax
=> 0x00000000004004ed <+23>:	movl   $0x1,(%rax)
   0x00000000004004f3 <+29>:	mov    $0x0,%eax
   0x00000000004004f8 <+34>:	pop    %rbp
   0x00000000004004f9 <+35>:	retq   
End of assembler dump.
(gdb) list
11	
12	    int *a = NULL;
13	
14	
15	
16	    (*a) = 1;
17	
18	
19	
20	    return 0;

```

# GDB list命令可以查看函数周围的源代码
可以看出代码在中为指向NULL的指针赋值，产生段错误；







