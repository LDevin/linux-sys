[TOC]

 ## System V IPC概述

- System V引入了三种高级进程间通信机制

1. 消息队列、共享内存和信号量

- IPC对象(消息队列、共享内存和信号量)存在于内核而不是文件系统中，由用户控制释放(用户管理IPC对象的生命周期)，不像管道的释放由内核控制。
- IPC对象通过其标识来引用和访问，所有的IPC对象在内核空间中唯一性标识ID，在用户空间中的唯一性标识称为Key.

- IPC对象是全局对象，可以通过ipcs，ipcrm等命令来查看或删除
- 每个IPC对象都由get函数创建

1. msgget,shmget,semget，调用get函数时必须指定关键字key

```bash
andrew@andrew-Thurley:/work/linux-sys$ ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息      

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     连接数  状态      
0x00000000 884736     andrew     600        16777216   2                       
0x00000000 786433     andrew     600        524288     2          目标       
0x00000000 983042     andrew     600        524288     2          目标       
0x00000000 655363     andrew     600        524288     2          目标       
0x00000000 1933316    andrew     700        30072      2          目标       
0x00000000 1081349    andrew     600        524288     2          目标       
0x00000000 1409030    andrew     600        524288     2          目标       
0x00000000 1572871    andrew     600        524288     2          目标       
0x00000000 1835016    andrew     600        524288     2          目标       
0x51010013 1638409    andrew     600        1          1                       
0x00000000 1736714    andrew     600        268435456  2          目标       
0x00000000 2031627    andrew     600        524288     2          目标       
0x00000000 2064396    andrew     600        524288     2          目标       
0x00000000 2162701    andrew     600        524288     2          目标       
0x00000000 2195470    andrew     600        4194304    2          目标       
0x00000000 2326544    andrew     600        524288     2          目标       
0x00000000 2424849    andrew     600        524288     2          目标       
0x00000000 2555922    andrew     600        2097152    2          目标       
0x00000000 2850835    andrew     700        222828     2          目标       

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
0x51010012 32768      andrew     600        1 
```

# 消息队列

- 消息队列是内核中的一个链表
- 用户进程将数据传输到内核后，内核重新添加一些如用户ID,组ID，读写进程的ID和优先级等相关信息后并打成一个数据包称为消息
- 允许一个进程或者多个进程往消息队列中写消息和读消息，但一个消息只能被一个进程读取，读取完毕后就自动删除

- 消息队列具有一定的FIFO的特性，消息可以按照顺序发送到队列中，也可以几种不同的方式从队列中读取，每一个消息对垒在内核中用一个唯一的IPC标识ID表示
- 消息队列的实现包括创建和打开队列、发送消息、读取消息和控制消息队列四中操作

## 创建或打开消息队列

```c
#include <sys/msg.h>
int msgget(key_t key, int flag);
返回：成功返回内核中消息队列的标识ID，出错返回-1
```

## 消息控制
```c
#include <sys/msg.h>
int msgctl(int msgid, intcmd, struct msqid_ds *buf);;
返回：成功返回0，出错返回-1
```

## 发送消息

```c
#include <sys/msg.h>
int msgsnd(int msgqid, const void *ptr, size_t nbytes,int flag);
返回：成功返回0，出错返回-1
ptr:
struct mymesg{
    long mytype;
    char mtext[512];
}
```

- nbytes 指定消息的大小，不包括mtype的大小
- mtype指消息的类型，它由一个整数来代表，并且它只能是大于0的整数
- mtext是消息数据本身
- 在linux中，消息的最大长度是4056个字节，其中包括mtype，它占有4个字节
- 结构体mymesg用户可自定义，但第一个成员必须是mytype

##  接收消息

```c
#include <sys/msg.h>
ssize_t msgrcv(int msgqid, void *ptr,size_t nbytes,long type, int flag);
返回：成功返回消息的数据部分长度，出错返回-1
    type : 消息类型
    type == 0 : l获得消息队列中的第一个消息
    type > 0 : 获得消息队列中类型为type的第一个消息
    type < 0 : 获得消息中小于或等于type和绝对值的消息`
```

























