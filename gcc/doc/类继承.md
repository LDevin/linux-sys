[TOC]

## C++中类和继承

![](https://img.shields.io/github/forks/zzu-andrew/linux-sys.svg)![](https://img.shields.io/github/license/zzu-andrew/Markdown.svg)![](https://img.shields.io/github/stars/zzu-andrew/linux-sys.svg)![](https://img.shields.io/github/issues/zzu-andrew/linux-sys.svg)

## 实现多态

- 同一个方法在派生类中和基类中行为是不同的，换句话说，方法的行为是不同的，换句话说方法的行为屈居于调用该方法的对象

**实现方式**

1. 在派生类中重新定义基类的方法
2. 使用虚方法

**析构函数**

- 如果析构函数不是虚的，将只调用指针对应类型的析构函数，如果析构函数是虚的，将调用指针指向对象的析构函数；因此，基类的析构函数通常声明为虚函数，这样定义基类对象的指针类型，指向继承类的对象，在调用析构函数的时候能够调用继承类的析构函数，而不是基类的析构函数。
- 将类中的方法声明为虚的，当使用基类类型的指针指向继承类的时候，通过该指针调用的函数，若是继承类中有声明，基类中也有声明但是是虚的，调用的函数将是继承类中的，若是基类中声明的不是虚的，将调用基类中的函数，因为将按照指针类型对函数进行调用。

**虚函数**

- 使用虚函数，在内存和执行速度方面会有一定的成本

  1. 没分对象都将增大，增大的量为存储地址的空间
  2. 每个类，编译器都将创建一个虚函数地址表(数组)；
  3. 每个函数的调用，都需要执行一项额外的操作，即到表中查找地址

  - 构造函数不能使虚函数，派生类不继承基类的构造函数
  - 析构函数应当是虚函数，除非类不作为基类
  - 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数，如果这种方式使用会引入问题，可以让友元函数使用虚成员函数来解决





$$
x^{2}+y^{2}+D x+E y+F=0
$$






















































